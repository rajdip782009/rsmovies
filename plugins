from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, Message
from pyrogram import Client, filters
from configs import Config
from helpers import *
from TeamTeleRoid.database import db



@Client.on_message(filters.channel & filters.incoming)
async def channel_link_handler(c:Client, m:Message):
    channel_id = m.chat.id
    
    channel_id = await db.get_channel(channel_id)
    if channel_id:
        msg = await m.copy(
            chat_id=Config.CHANNEL_ID,
        )
        try:
            return await main_convertor_handler(c,msg,"mdisk", True)
        except Exception as e:
            print(e)




@Client.on_message(filters.command("allow") & filters.private &  filters.chat(Config.BOT_OWNER))
async def add_channel_handler(_, m: Message):

    if len(m.command) == 1:
        return await m.reply('Command Usage: /allow -100xxx')

    if len(m.command) == 2:
        channel_id=m.command[1]
        if await db.get_channel(channel_id):
            return await m.reply('Channels is already added')
        else:
            await db.allow(channel_id=channel_id,)
            return await m.reply('Channel ID added successfully')



@Client.on_message(filters.command("disallow") & filters.private & filters.chat(Config.BOT_OWNER))
async def remove_channel_handler(c: Client, m: Message):
    if len(m.command) == 1:
        return await m.reply('Command Usage: /disallow -100xxx')

    channel_id=m.command[1]
    channel_id = await db.get_channel(channel_id)
    if not channel_id:
        return await m.reply("No channel found")

    await db.disallow(m.command[1])
    return await m.reply("Channel removed")



@Client.on_message(filters.command("channels") & filters.private & filters.chat(Config.BOT_OWNER))
async def get_channels_list(c: Client, m: Message):
    get_channel = await db.get_channel_count()
    count = get_channel['count']
    channels = get_channel['channels']

    msg = f"""
Total Chats: {count}

Chat List:

"""

    for i, channel in enumerate(channels):
        channel_id = channel['channel_id']
        msg += f"{i+1}) `-100{channel_id}`\n"

    return await m.reply(msg)
# (c) @Royalkrrishna
from pyrogram import Client, filters
import datetime
from configs import Config
from TeamTeleRoid.database import db
from pyrogram.types import Message

@Client.on_message(filters.private)
async def handle_user_status(bot:Client, cmd:Message):
    chat_id = cmd.from_user.id

    if not await db.is_user_exist(chat_id):
        print("True")
        await db.add_user(chat_id)
        await bot.send_message(
            Config.LOG_CHANNEL,
            f"#NEW_USER: \n\nNew User [{cmd.from_user.first_name}](tg://user?id={cmd.from_user.id}) started @{Config.BOT_USERNAME} !!"
        )

    ban_status = await db.get_ban_status(chat_id)
    if ban_status["is_banned"]:
        if (
                datetime.date.today() - datetime.date.fromisoformat(ban_status["banned_on"])
        ).days > ban_status["ban_duration"]:
            await db.remove_ban(chat_id)
        else:
            await cmd.reply_text("You Are Ban To Use This Bot.ðŸ˜œ", quote=True)
            return
    await cmd.continue_propagation()


from configs import Config
from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from TeamTeleRoid.database import db


@Client.on_message(filters.command("help") & filters.private)
async def help_handler(_, event: Message):
    await event.reply_text(Config.ABOUT_HELP_TEXT.format(event.from_user.mention),
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("Our Channel", url="https://t.me/fym_update"),
             InlineKeyboardButton("Our Group", url="https://t.me/iPopcornMovieGroup"),
             InlineKeyboardButton("About", callback_data="About_msg")]
        ])
    )

@Client.on_message(filters.command("total_users") & filters.private &  filters.chat(Config.BOT_OWNER))
async def total_users(_, event: Message):
    total_users = await db.total_users_count()
    msg = f"""
    Users: {total_users} users

    """
    await event.reply_text(msg)
    

@Client.on_message( filters.command("start") & filters.private)
async def start_handler(_,event: Message):
    await event.reply_photo(
        photo='https://telegra.ph/file/815636d239a27fe41a7e1.jpg',
        caption=Config.START_MSG.format(event.from_user.mention),
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("Our Channel", url="https://t.me/Fym_update"),
             InlineKeyboardButton("Our Group", url="https://t.me/iPopcornMovieGroup")],

             [InlineKeyboardButton("About", callback_data="About_msg"),
             InlineKeyboardButton("Help", callback_data="Help_msg")
             ]
        ])
    )

@Client.on_message(filters.text)
async def give_filter(client, message):
    if "livegram" in message.text.lower():
        await message.delete()
        return


# (c) @RoyalKrrishna
from TeamTeleRoid.database import db
from configs import Config
from pyrogram import Client, filters, idle
from pyrogram.types import Message

@Client.on_message(filters.command("connect") & filters.chat(Config.BOT_OWNER) & filters.private)
async def connnect_group(c: Client, m: Message):

    if len(m.command) == 1:
        return await m.reply('Command Usage: /connect group_id')
    
    if len(m.command) == 2:

        group_id=m.command[1]

        if await db.get_group(group_id):
            return await m.reply('Group Already Connected')
        else:
            await db.connect(group_id=group_id)
            return await m.reply('Group connected successfully')



@Client.on_message(filters.command("disconnect") & filters.chat(Config.BOT_OWNER) & filters.private)
async def disconnnect_group(c: Client, m: Message):

    if len(m.command) == 1:
        return await m.reply('Command Usage: /disconnect group_id')
    
    if len(m.command) == 2:

        group_id=m.command[1]

        if await db.get_group(group_id):
            await db.disconnect(group_id=group_id)
            return await m.reply('Group disconnected')
        else:
            return await m.reply('Group is not connected')
import os
from pyrogram import Client, filters
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from pyrogram.errors import UserNotParticipant
from configs import Config

from pyrogram.types import Message


# @Client.on_message(filters.private & filters.incoming)
async def forcesub(c:Client, m:Message):
    owner = await c.get_users(int(Config.BOT_OWNER))
    if Config.FORCE_SUB:
        try:
            user = await c.get_chat_member(Config.UPDATES_CHANNEL_USERNAME, m.from_user.id)
            if user.status == "kicked":
               await m.reply_text("**Hey you are banned ðŸ˜œ**", quote=True)
               return
        except UserNotParticipant:
            buttons = [[InlineKeyboardButton(text='Updates Channel ðŸ”–', url=f"https://t.me/{Config.UPDATES_CHANNEL_USERNAME}")]]
            if m.text:
                if (len(m.text.split()) > 1) & ('start' in m.text):
                    decoded_data = await decode(m.text.split()[1])
                    chat_id, msg_id = decoded_data.split('_')
                    buttons.append([InlineKeyboardButton('ðŸ”„ Refresh', callback_data=f'refresh+{chat_id}+{msg_id}')])
            await m.reply_text(
                f"Hey {m.from_user.mention(style='md')} you need join My updates channel in order to use me ðŸ˜‰\n\n"
                "__Press the Following Button to join Now ðŸ‘‡__",
                reply_markup=InlineKeyboardMarkup(buttons),
                quote=True
            )
            
            return
        except Exception as e:
            print(e)
            await m.reply_text(f"Something Wrong. Please try again later or contact {owner.mention(style='md')}", quote=True)
            return

    await m.continue_propagation()


@Client.on_callback_query(filters.regex('^refresh'))
async def refresh_cb(c, m):
    UPDATE_CHANNEL = Config.UPDATES_CHANNEL_USERNAME
    OWNER_ID = Config.BOT_OWNER
    owner = await c.get_users(int(OWNER_ID))
    # Checking if the FORCE_SUB is enabled or not.
    if Config.FORCE_SUB:
        try:
            user = await c.get_chat_member(UPDATE_CHANNEL, m.from_user.id)
            if user.status == "kicked":
               try:
                   await m.message.edit("**Hey you are banned ðŸ˜œ**")
               except:
                   pass
               return
        except UserNotParticipant:
            await m.answer('You are not yet joined our channel. First join and then press refresh button ðŸ¤¤', show_alert=True)
            return
        except Exception as e:
            print(e)
            await m.message.edit(f"Something Wrong. Please try again later or contact {owner.mention(style='md')}")
            return        
    await m.message.delete()

import base64
async def decode(base64_string):
    base64_bytes = base64_string.encode("ascii")
    string_bytes = base64.b64decode(base64_bytes) 
    string = string_bytes.decode("ascii")
    return string

import re
from TeamTeleRoid.database import db
from configs import Config
import requests



# ##############################################################################################################
        
async def get_mdisk(link, api=Config.MDISK_API):
    url = 'https://diskuploader.mypowerdisk.com/v1/tp/cp'
    param = {'token': api, 'link': link
             }
    res = requests.post(url, json=param)

    try:
        shareLink = res.json()
        link = shareLink["sharelink"]
    except Exception as e:
        print(e)
    return link


async def replace_mdisk_link(text, api=Config.MDISK_API):
    links = re.findall(r'https?://mdisk.me[^\s]+', text)
    for link in links:
        mdisk_link = await get_mdisk(link, api)
        text = text.replace(link, mdisk_link)

    return text


async def group_link_convertor(group_id, text):
    api = await db.get_api_id(group_id)
    if api:
        answer = await replace_mdisk_link(text, str(api['api']))
    else:
        answer = text
    return answer



import re
from pyrogram import Client, filters
from pyrogram.types import Message
from TeamTeleRoid.database import db
from configs import Config
import requests
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton

VERIFY = {}

@Client.on_message(filters.command("remove_api") & filters.group)
async def remove_api_handler(c: Client, m: Message):
    global VERIFY
    chat_id = m.chat.id
    user_id = m.from_user.id if m.from_user else None
    if VERIFY.get(str(chat_id)) == None: # Make Admin's ID List
        admin_list = []
        async for x in c.iter_chat_members(chat_id=chat_id, filter="administrators"):
            admin_id = x.user.id 
            admin_list.append(admin_id)
        admin_list.append(None)
        VERIFY[str(chat_id)] = admin_list

    if not user_id in VERIFY.get(str(chat_id)): # Checks if user is admin of the chat
        return

    user_id = m.from_user.id

    if not user_id:
        return await m.reply("Anonymous admin can't remove api")


    api = await db.get_api_id(chat_id)
    if not api:
        return await m.reply("No API found for chat %s" % chat_id)
    reply_markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("Sure !", callback_data=f"remove_api#{chat_id}"),
            InlineKeyboardButton("Cancel", callback_data=f"cancel_removeapi"),]
        ])
    

    return await m.reply('Are you Sure you want to remove your api from this chat?',
    reply_markup=reply_markup)

from telegraph.aio import Telegraph
import markdown


async def telegraph_handler(title, html, author):
    telegraph = Telegraph()
    if len(title) >= 20:
        title = title[:20]
    await telegraph.create_account(short_name=title, author_name=author)
    response = await telegraph.create_page(
        title=title,
        html_content=html,
        author_name=author

    )
    return response['url']


async def markdown_to_html(markdown_txt):
    md = markdown.Markdown()
    html = md.convert(markdown_txt)
    return html



# (c) @RoyalKrrishna
from TeamTeleRoid.database import db
from configs import Config
from pyrogram import Client, filters, idle
from pyrogram.types import Message

VERIFY = {}
@Client.on_message(filters.command("add_api") & filters.group)
async def group_hanler(c: Client, m: Message):
    global VERIFY
    chat_id = m.chat.id
    user_id = m.from_user.id if m.from_user else None


    if VERIFY.get(str(chat_id)) == None: # Make Admin's ID List
        admin_list = []
        async for x in c.iter_chat_members(chat_id=chat_id, filter="administrators"):
            admin_id = x.user.id 
            admin_list.append(admin_id)
        admin_list.append(None)
        VERIFY[str(chat_id)] = admin_list

    if not user_id in VERIFY.get(str(chat_id)): # Checks if user is admin of the chat
        return


    if len(m.command) == 1:
        return await m.reply('Command Usage: /add_api your api key')
    if not await db.get_group(chat_id):
        return await m.reply('Group is not added by the owner')
    if len(m.command) == 2:
        api=m.command[1]
        if await db.get_api_id(chat_id):
            await db.update_user_api(group_id=m.chat.id, api=api)
            return await m.reply('API ID Updated successfully')
        else:
            await db.add_user_api(group_id=m.chat.id, api=api)
            return await m.reply('API ID added successfully')
# (c) @RoyalKrrishna
import time
import string
import random
import datetime
import aiofiles
import asyncio
import traceback
import aiofiles.os
from configs import Config
from pyrogram.errors import FloodWait, InputUserDeactivated, UserIsBlocked, PeerIdInvalid
from pyrogram.types import Message
from pyrogram import Client, filters
from TeamTeleRoid.database import db


broadcast_ids = {}

@Client.on_message(filters.command("broadcast") & filters.private & filters.chat(Config.BOT_OWNER))
async def broadcast_handler(c:Client, m:Message):
    if m.reply_to_message:
        await main_broadcast_handler(m, db)
    else:
        await m.reply_text("Reply to the message you want to broadcast")


async def send_msg(user_id, message):
    try:
        if Config.BROADCAST_AS_COPY == "False":
            await message.forward(chat_id=user_id)
        elif Config.BROADCAST_AS_COPY == "True":
            await message.copy(chat_id=user_id)
        return 200, None
    except FloodWait as e:
        await asyncio.sleep(e.x)
        return send_msg(user_id, message)
    except InputUserDeactivated:
        return 400, f"{user_id} : deactivated\n"
    except UserIsBlocked:
        return 400, f"{user_id} : blocked the bot\n"
    except PeerIdInvalid:
        return 400, f"{user_id} : user id invalid\n"
    except Exception as e:
        return 500, f"{user_id} : {traceback.format_exc()}\n"


async def main_broadcast_handler(m:Message, db):
    all_users = await db.get_all_users()
    broadcast_msg = m.reply_to_message
    while True:
        broadcast_id = ''.join([random.choice(string.ascii_letters) for i in range(3)])
        if not broadcast_ids.get(broadcast_id):
            break
    out = await m.reply_text(
        text=f"Broadcast Started! You will be notified with log file when all the users are notified."
    )
    start_time = time.time()
    total_users = await db.total_users_count()
    done = 0
    failed = 0
    success = 0
    broadcast_ids[broadcast_id] = dict(
        total=total_users,
        current=done,
        failed=failed,
        success=success
    )
    async with aiofiles.open('broadcast.txt', 'w') as broadcast_log_file:
        for user in all_users:
            sts, msg = await send_msg(
                user_id=int(user['id']),
                message=broadcast_msg
            )
            if msg is not None:
                await broadcast_log_file.write(msg)
            if sts == 200:
                success += 1
            else:
                failed += 1
            if sts == 400:
                await db.delete_user(user['id'])
            done += 1
            if broadcast_ids.get(broadcast_id) is None:
                break
            else:
                broadcast_ids[broadcast_id].update(
                    dict(
                        current=done,
                        failed=failed,
                        success=success
                    )
                )
    if broadcast_ids.get(broadcast_id):
        broadcast_ids.pop(broadcast_id)
    completed_in = datetime.timedelta(seconds=int(time.time() - start_time))
    await asyncio.sleep(3)
    await out.delete()
    if failed == 0:
        await m.reply_text(
            text=f"broadcast completed in `{completed_in}`\n\nTotal users {total_users}.\nTotal done {done}, {success} success and {failed} failed.",
            quote=True
        )
    else:
        await m.reply_document(
            document='broadcast.txt',
            caption=f"broadcast completed in `{completed_in}`\n\nTotal users {total_users}.\nTotal done {done}, {success} success and {failed} failed.",
            quote=True
        )
    await aiofiles.os.remove('broadcast.txt')

from TeamTeleRoid.database import db
from configs import Config
from pyrogram import Client, filters
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery


@Client.on_callback_query()
async def button(bot, cmd: CallbackQuery):
        cb_data = cmd.data
        if "About_msg" in cb_data:
            await cmd.message.edit(
            text=Config.ABOUT_BOT_TEXT,
            disable_web_page_preview=True,
            reply_markup=InlineKeyboardMarkup(
                [
                    [
                        InlineKeyboardButton("Our Channel", url="https://t.me/FYM_Update"),
                        InlineKeyboardButton("Our Group", url="https://t.me/iPopcornMovieGroup")
                    ],
                    [
                        InlineKeyboardButton("Developer", url="https://t.me/RoyalKrrishna"),
                        InlineKeyboardButton("Home", callback_data="gohome")
                    ]
                ]
            ),
            parse_mode="html"
        )
        elif "Help_msg" in cb_data:
            await cmd.message.edit(
            text=Config.ABOUT_HELP_TEXT,
            disable_web_page_preview=True,
            reply_markup=InlineKeyboardMarkup(
                [
                    [
                        InlineKeyboardButton("About", callback_data="About_msg"),
                        InlineKeyboardButton("Our Channel", url="https://t.me/FYM_Update")
                    ], 
                                        [
                        InlineKeyboardButton("Owner", url="https://t.me/RoyalKrrishna"),
                        InlineKeyboardButton("Home", callback_data="gohome")
                    ]
                ]
            ),
            parse_mode="html"
        )
        elif "gohome" in cb_data:
            await cmd.message.edit(
            text=Config.HOME_TEXT.format(cmd.from_user.mention),
            disable_web_page_preview=True,
            reply_markup=InlineKeyboardMarkup(
                [
                                        [
                        InlineKeyboardButton("Help", callback_data="Help_msg"),
                        InlineKeyboardButton("About", callback_data="About_msg")
                    ],
                    [
                        InlineKeyboardButton("Support", url="https://t.me/RoyalKrrishna"),
                        InlineKeyboardButton("Channel", url="https://t.me/FYM_Update")
                    ]
                ]
            ),
            parse_mode="html"
        )

        elif "remove_api" in cb_data:
            _, group_id = cb_data.split("#")
            await db.remove_user_api(int(group_id))
            await cmd.message.edit("Deleted Successfully")
            return
        elif "cancel_removeapi" in cb_data:
            await cmd.message.delete()

